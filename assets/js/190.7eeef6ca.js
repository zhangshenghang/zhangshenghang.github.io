(window.webpackJsonp=window.webpackJsonp||[]).push([[190],{554:function(s,t,e){"use strict";e.r(t);var n=e(8),v=Object(n.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p",[s._v("[toc]")]),s._v(" "),t("h2",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[s._v("#")]),s._v(" 概述")]),s._v(" "),t("p",[t("em",[s._v("动态表")]),s._v("是 Flink Table & SQL API的核心概念，用于统一有界和无界数据的处理。")]),s._v(" "),t("p",[s._v("动态表只是一个逻辑概念，因此 Flink 并不拥有数据。相应的，动态表的内容存储在外部系统（ 如数据库、键值存储、消息队列 ）或文件中。")]),s._v(" "),t("p",[t("em",[s._v("动态 sources")]),s._v(" 和"),t("em",[s._v("动态 sinks")]),s._v(" 可用于从外部系统读取数据和向外部系统写入数据。在文档中，sources 和 sinks 常在术语"),t("em",[s._v("连接器")]),s._v(" 下进行总结。")]),s._v(" "),t("p",[s._v("在许多情况下，开发人员不需要从头开始创建新的连接器，而是希望稍微修改现有的连接器或 hook 到现有的 stack。在其他情况下，开发人员希望创建专门的连接器。")]),s._v(" "),t("p",[s._v("本节对这两种用例都有帮助。它解释了表连接器的一般体系结构，从 API 中的纯粹声明到在集群上执行的运行时代码")]),s._v(" "),t("p",[s._v("实心箭头展示了在转换过程中对象如何从一个阶段到下一个阶段转换为其他对象。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://s2.loli.net/2023/08/17/9DKnrk2PwQLxGWF.png",alt:"table_connectors"}})]),s._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[s._v("#")]),s._v(" 参考")]),s._v(" "),t("p",[s._v("https://dongkelun.com/2023/05/24/flinkUserDefinedConnector/")]),s._v(" "),t("p",[s._v("https://nightlies.apache.org/flink/flink-docs-release-1.17/zh/docs/dev/table/sourcessinks/#%E5%8A%A8%E6%80%81%E8%A1%A8%E7%9A%84-sink-%E7%AB%AF")])])}),[],!1,null,null,null);t.default=v.exports}}]);